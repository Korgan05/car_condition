<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Car Condition</title>
  <link rel="icon" href="/static/favicon.svg" type="image/svg+xml" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; background: #0b1020; color: #eaeef3; margin: 0; }
    header { padding: 16px 24px; background: #121833; font-weight: 600; }
    main { max-width: 900px; margin: 24px auto; padding: 16px; background: #141a3a; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.25); }
    .row { display: flex; gap: 24px; flex-wrap: wrap; }
    .card { flex: 1 1 340px; background: #0f1430; border: 1px solid #242a52; border-radius: 12px; padding: 16px; }
    h1 { margin: 0 0 12px; font-size: 20px; }
    h2 { margin: 0 0 8px; font-size: 16px; color: #a8b0d8; }
    input[type=file] { padding: 8px; }
    button { background: #3b82f6; color: white; border: none; padding: 10px 16px; border-radius: 8px; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: progress; }
    .result { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background: #0a0f2b; border: 1px solid #272f5d; border-radius: 8px; padding: 12px; white-space: pre-wrap; }
    .grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
    .badge { display: inline-block; padding: 4px 8px; border-radius: 999px; background: #1f2a5a; border: 1px solid #2f3a7a; }
    .badge.ok { background: #103c2b; border-color: #1f6d4b; }
    .badge.bad { background: #3c1010; border-color: #6d1f1f; }
    .file { font-weight: 600; margin-bottom: 6px; color: #c9d4ff; }
    .line { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:10px; }
    .muted { color:#8ea0d0; font-size:12px; }
    .legend { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; }
    .chip { padding:3px 8px; border-radius:999px; border:1px solid #2f3a7a; background:#0a0f2b; font-size:12px; }
  .chip.green { border-color:#3a8a5a; color:#8ee9b0; }
  .chip.yellow { border-color:#8a7a3a; color:#ffe08a; }
  .chip.dirt { border-color:#3a8a5a; color:#8ee9b0; }
  .chip.scratch { border-color:#8a7a3a; color:#ffe08a; }
  .chip.dent { border-color:#6b4b2f; color:#ffb38a; }
  .chip.rust { border-color:#7a2e2e; color:#f7a1a1; }
  .chip.damage { border-color:#6a4cff; color:#c7b8ff; }
    .conf-wrap { margin-top:10px; }
    .conf-wrap input[type=range] { width: 100%; }
  </style>
</head>
<body>
  <header>Состояние авто — чистота и повреждения</header>
  <main>
    <div class="row">
      <div class="card">
  <h1>Загрузка фото</h1>
  <p>Загрузите одно или несколько изображений автомобиля (JPG/PNG/BMP).</p>
  <input id="fileInput" type="file" accept="image/*" multiple />
        <div style="height: 12px;"></div>
  <button id="sendBtn">Отправить</button>
        <div style="height: 12px;"></div>
        <div class="conf-wrap">
          <h2>Чувствительность детектора</h2>
          <div class="muted">Если объектов мало — сдвиньте влево.</div>
          <input id="confSlider" type="range" min="0.01" max="0.50" step="0.01" />
          <div class="muted">Порог: <span id="confValue">0.05</span></div>
        </div>
        <div class="legend">
          <span class="chip dirt">грязь — зелёный</span>
          <span class="chip scratch">царапина — жёлтый</span>
          <span class="chip dent">вмятина — оранжевый</span>
          <span class="chip rust">ржавчина — красный</span>
        </div>
      </div>
      <div class="card">
  <h1>Результаты</h1>
        <div id="meta" class="muted" style="margin-bottom:8px;"></div>
  <div id="preview"></div>
        <div style="height: 12px;"></div>
  <div id="labels" class="grid"></div>
        <div style="height: 12px;"></div>
      </div>
    </div>
  </main>
  <script>
    const input = document.getElementById('fileInput');
    const btn = document.getElementById('sendBtn');
    const preview = document.getElementById('preview');
  const labels = document.getElementById('labels');
  const meta = document.getElementById('meta');
  const confSlider = document.getElementById('confSlider');
  const confValue = document.getElementById('confValue');
  const classify = []; // хранение вердиктов классификации по индексу файла
  // детекция всегда отрисовывается
    // load metadata
    fetch('/api/metadata').then(r=>r.json()).then(m=>{
      let parts = [];
      parts.push(`модель: ${m.backbone}`);
      if (m.yolo_loaded) {
        parts.push(`YOLO: ${m.yolo_weights || 'загружен'}`);
        if (m.yolo_classes?.length) parts.push(`классы: ${m.yolo_classes.join(', ')}`);
      } else {
        parts.push('YOLO: не загружен — боксы недоступны');
      }
      meta.textContent = parts.join(' | ');
    }).catch(()=>{});
    // убрали тех. JSON — оставляем только человеко-понятные подписи

    // init detector sensitivity
    const savedConf = parseFloat(localStorage.getItem('yoloConf') || '0.05');
    const clamp = (v,min,max)=>Math.min(max,Math.max(min,v));
  const confMin = 0.01, confMax = 0.50;
    const state = { conf: clamp(savedConf, confMin, confMax) };
    confSlider.value = String(state.conf);
    confValue.textContent = state.conf.toFixed(2);
    confSlider.addEventListener('input', () => {
      state.conf = clamp(parseFloat(confSlider.value || '0.05'), confMin, confMax);
      confValue.textContent = state.conf.toFixed(2);
      localStorage.setItem('yoloConf', String(state.conf));
    });

    input.addEventListener('change', () => {
      preview.innerHTML = '';
      if (!input.files?.length) return;
      [...input.files].slice(0, 6).forEach((f, idx) => {
        const img = document.createElement('img');
        img.style.maxWidth = '100%';
        img.style.borderRadius = '8px';
        img.style.marginBottom = '8px';
        img.dataset.idx = String(idx);
        img.src = URL.createObjectURL(f);
        preview.appendChild(img);
      });
    });

    btn.addEventListener('click', async () => {
      if (!input.files?.length) return alert('Выберите файл(ы)');
      btn.disabled = true; btn.textContent = 'Загрузка…';
      try {
        const fd = new FormData();
        [...input.files].forEach(f => fd.append('files', f));
  const resp = await fetch('/api/batch_predict', { method: 'POST', body: fd });
        if (!resp.ok) throw new Error(await resp.text());
  const data = await resp.json();

  labels.innerHTML = '';
        if (data?.results?.length) {
          data.results.forEach((item, idx) => {
            const wrap = document.createElement('div');
            wrap.className = 'line';
            if (item.error) {
              const err = document.createElement('div');
              err.className = 'badge bad';
              err.textContent = `❌ ${item.filename || ''}: ${item.error}`;
              wrap.appendChild(err);
              labels.appendChild(wrap);
              return;
            }

            // Используем решения сервера (автопороги из чекпойнта)
            let cleanLabel = item.pred_clean_ru || (item.pred_clean === 'clean' ? 'чистый' : 'грязный');
            let damageLabel = item.pred_damage_ru || (item.pred_damage === 'damaged' ? 'битый' : 'целый');

            const title = document.createElement('div');
            title.className = 'file';
            title.textContent = item.filename || '';
            labels.appendChild(title);

            const dirtBadge = document.createElement('span');
            const dmgBadge = document.createElement('span');

            // Вердикты в явном виде
            const dirtIsClean = (cleanLabel === 'чистый');
            dirtBadge.className = 'badge ' + (dirtIsClean ? 'ok' : 'bad');
            dirtBadge.textContent = dirtIsClean ? `Грязь: нет (${Math.round(item.clean_prob*100)}%)` : `Грязь: есть (${Math.round((1-item.clean_prob)*100)}%)`;

            const dmgIsDamaged = (damageLabel === 'битый');
            dmgBadge.className = 'badge ' + (dmgIsDamaged ? 'bad' : 'ok');
            dmgBadge.textContent = dmgIsDamaged ? `Повреждения: есть (${Math.round(item.damaged_prob*100)}%)` : `Повреждения: нет (${Math.round((1-item.damaged_prob)*100)}%)`;

            wrap.appendChild(dirtBadge);
            wrap.appendChild(dmgBadge);
            labels.appendChild(wrap);

            // запомним вердикт классификации для последующей подсказки
            classify[idx] = {
              dirty: !dirtIsClean,
              damaged: dmgIsDamaged,
              cleanProb: item.clean_prob,
              damagedProb: item.damaged_prob,
            };

            // Контейнер для сводки детекции заполним после детекта
            const detLine = document.createElement('div');
            detLine.className = 'line';
            detLine.dataset.idx = String(idx);
            detLine.innerHTML = '<span class="muted">Детектор (YOLO): загрузка…</span>';
            labels.appendChild(detLine);
          });
        }

        // Боксы на фото: повреждения (YOLO) + грязь (CAM) — единый canvas на изображение
        {
          [...preview.querySelectorAll('img.det,canvas.det')].forEach(n => n.remove());
          for (let i = 0; i < Math.min(input.files.length, 6); i++) {
            const f = input.files[i];
            const url = URL.createObjectURL(f);
            const baseImg = new Image();
            baseImg.onload = async () => {
              try {
                const canvas = document.createElement('canvas');
                canvas.className = 'det';
                canvas.width = baseImg.naturalWidth;
                canvas.height = baseImg.naturalHeight;
                canvas.style.maxWidth = '100%';
                canvas.style.border = '1px solid #2f3a7a';
                canvas.style.borderRadius = '8px';
                canvas.style.margin = '4px 0 6px 0';
                const ctx = canvas.getContext('2d');
                if (!ctx) return;
                ctx.drawImage(baseImg, 0, 0, canvas.width, canvas.height);

                // Получаем YOLO-детекции
                const fdFile = new FormData(); fdFile.append('file', f);
                const rDet = await fetch(`/api/detect?conf=${encodeURIComponent(state.conf.toFixed(2))}`, { method: 'POST', body: fdFile });
                const detJson = rDet.ok ? await rDet.json() : { detections: [] };
                // фильтруем только интересующие классы
                const wanted = new Set(['царапина','ржавчина','вмятина','грязь']);
                let detections = (detJson?.detections || []).filter(d => wanted.has((d.class||'').toLowerCase()));

                // Фолбэк: если YOLO не дал боксов, но классификатор видит проблему —
                // запрашиваем CAM-боксы для соответствующей головы и добавляем их.
                if ((!detections || detections.length === 0) && classify[i]) {
                  const clsVerdict = classify[i];
                  // полезная утилита
                  const camFetch = async (head) => {
                    const fdCam = new FormData(); fdCam.append('file', f);
                    const rCam = await fetch(`/api/heatmap_boxes?head=${encodeURIComponent(head)}`, { method: 'POST', body: fdCam });
                    if (!rCam.ok) return null;
                    try { return await rCam.json(); } catch { return null; }
                  };
                  // damaged → "повреждение" (фиолетовый), dirty → "грязь" (зелёный)
                  // можно вызывать обе, если обе задачи сработали
                  const camBoxes = [];
                  try {
                    if (clsVerdict.damaged) {
                      const r1 = await camFetch('damaged');
                      if (r1?.boxes?.length) camBoxes.push({ label: r1.label || 'повреждение', boxes: r1.boxes });
                    }
                  } catch {}
                  try {
                    if (clsVerdict.dirty) {
                      const r2 = await camFetch('dirty');
                      if (r2?.boxes?.length) camBoxes.push({ label: r2.label || 'грязь', boxes: r2.boxes });
                    }
                  } catch {}
                  if (camBoxes.length) {
                    const camDet = [];
                    for (const g of camBoxes) {
                      for (const b of g.boxes) {
                        if (Array.isArray(b) && b.length === 4) camDet.push({ box: b.map(Number), class: String(g.label||'') , score: 0.5 });
                      }
                    }
                    detections = camDet; // заменяем пустые YOLO-детекции CAM-боксами
                  }
                }

                // Рисуем YOLO-боксы: индивидуальные цвета по классам
                if (detections.length) {
                  ctx.lineWidth = Math.max(2, Math.round(Math.min(canvas.width, canvas.height) * 0.003));
                  ctx.fillStyle = 'rgba(0,0,0,0.6)';
                  ctx.font = `${Math.max(12, Math.round(canvas.width * 0.018))}px system-ui, Arial`;
                  ctx.textBaseline = 'top';
                  detections.forEach(d => {
                    const [x1,y1,x2,y2] = d.box || [];
                    if ([x1,y1,x2,y2].some(v => typeof v !== 'number')) return;
                    const w = x2 - x1, h = y2 - y1;
                    const cls = (d.class||'').toLowerCase();
                    let color = '#ffd54a'; // default scratch/yellow
                    if (cls === 'грязь') color = '#4ade80';       // green
                    else if (cls === 'вмятина') color = '#ff9f50'; // orange
                    else if (cls === 'ржавчина') color = '#ff6b6b'; // red
                    else if (cls === 'повреждение') color = '#a78bfa'; // violet (CAM fallback)
                    ctx.strokeStyle = color;
                    ctx.strokeRect(x1, y1, w, h);
                    const label = `${d.class || ''}`.trim();
                    const tw = ctx.measureText(label).width;
                    const th = Math.max(18, Math.round(canvas.width * 0.028));
                    const bx = Math.max(0, x1);
                    const by = Math.max(0, y1 - th);
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(bx, by, tw + 8, th);
                    ctx.fillStyle = color;
                    ctx.fillText(label, bx + 4, by + 2);
                  });
                }

                // Сводка по детекциям: подсчёт по классам
                const counts = { 'грязь':0, 'царапина':0, 'вмятина':0, 'ржавчина':0, 'повреждение':0 };
                for (const d of detections) {
                  const cls = (d.class||'').toLowerCase();
                  if (counts.hasOwnProperty(cls)) counts[cls]++;
                }
                const total = detections.length;
                const detLine = [...labels.querySelectorAll('.line')].find(el => el.dataset?.idx === String(i));
                if (detLine) {
                  detLine.innerHTML = '';
                  if (total === 0) {
                    const chip = document.createElement('span'); chip.className = 'chip'; chip.textContent = 'Объекты детектора не найдены (YOLO)'; detLine.appendChild(chip);
                    // если классификация говорит о наличии грязи/повреждений — подскажем, что это разные источники
                    const cls = classify[i] || {};
                    if (cls.dirty || cls.damaged) {
                      const note = document.createElement('span');
                      note.className = 'muted';
                      note.style.marginLeft = '8px';
                      note.textContent = 'Классификация видит проблему по фото целиком. Попробуйте снизить порог сверху или подключить веса с нужными классами.';
                      detLine.appendChild(note);
                    }
                  } else {
                    const totalChip = document.createElement('span'); totalChip.className = 'chip'; totalChip.textContent = `Найдено объектов: ${total}`; detLine.appendChild(totalChip);
                    const makeChip = (text, cls) => { const c = document.createElement('span'); c.className = 'chip ' + (cls||''); c.textContent = text; return c; };
                    if (counts['грязь']) detLine.appendChild(makeChip(`грязь: ${counts['грязь']}`, 'dirt'));
                    if (counts['царапина']) detLine.appendChild(makeChip(`царапина: ${counts['царапина']}`, 'scratch'));
                    if (counts['вмятина']) detLine.appendChild(makeChip(`вмятина: ${counts['вмятина']}`, 'dent'));
                    if (counts['ржавчина']) detLine.appendChild(makeChip(`ржавчина: ${counts['ржавчина']}`, 'rust'));
                    if (counts['повреждение']) detLine.appendChild(makeChip(`повреждение: ${counts['повреждение']}`, 'damage'));
                  }
                }

                // Заменяем превью-изображение на canvas
                const prevImg = preview.querySelector(`img[data-idx="${i}"]`);
                if (prevImg) prevImg.replaceWith(canvas); else preview.appendChild(canvas);
              } catch (e) {
                console.warn('overlay error', e);
              } finally {
                URL.revokeObjectURL(url);
              }
            };
            baseImg.src = url;
          }
        }
      } catch (e) {
        alert('Ошибка: ' + e);
      } finally {
        btn.disabled = false; btn.textContent = 'Отправить';
      }
    });
  </script>
</body>
</html>